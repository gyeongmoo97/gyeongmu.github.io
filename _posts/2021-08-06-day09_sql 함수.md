title:  "Day09_sql 함수"
excerpt: " 배운내용에 대하여 정리하여 본다. "

categories:

  - 일일 학습
    tags:
  - [Blog, SQL, Git]

toc: true
toc_sticky: true

date: 2021-08-06
last_modified_at: 2021-08-06

--

# 집계함수

ex

```sql
select * from professor;

-- 교수테이블의 전체 급여가 궁금하다
select pay from professor;
--교수 테이블 전체의 급여 합
select sum(pay) 교수님급여합 from professor;
--
select sum(pay) 교수님급여합, avg(pay) 교수님급여평균 from professor;

select max(pay), min(pay) from professor;

select sum(pay), sum(bonus), avg(bonus), count(bonus), count(pay),count(*) from Professor;

select rank(490) within Group(Order by pay desc)
from professor;
```



![image-20210809090552435](C:\Users\mwe22\AppData\Roaming\Typora\typora-user-images\image-20210809090552435.png)

### sum

합계를 구해줌



### avg

null 제외하고 평균 값 구해줌



### max

최대값 구해줌



### count

```sql
select sum(pay), sum(bonus), avg(bonus), count(bonus), count(pay),count(*) from Professor;
```

***는 null 포함한 값을 반환한다. (중요)**

일반적으로 count(filed) 하면 null 값을 제외한 값에 대해서만 

카운팅 진행한다.

![image](https://user-images.githubusercontent.com/65274952/128649948-a9951ad4-2e18-4fb7-9056-6aee0c5d90ea.png)

### rank

rank는 칼럼값에 없어도 그 값이 있다면 몇등인지 알려준다.





### ex gift table

![image](https://user-images.githubusercontent.com/65274952/128650073-5a27fe88-958e-403a-99eb-a8613fc4a006.png)





```sql
select * from gift;

select count(*) from gift;
--null 포함한 항목의 수
select count(g_end) from gift;
insert into gift(gname, e_end) values('청소기', 3000);



--최저가 합 최고가 합
select sum(g_start) "최저가 합", sum(g_end) "최고가 합" from gift;

--최고가에서 제일 비싼 상품 최저가에서 제일싼 가격
select max(g_end) "최고가에서 제일 비싼상품", min(g_start) "최저가에서 제일 싼가격" 
from gift;
--600001 금액의 상품이 가격에서 몇 번 째로 비싼지?
select rank(600001) within group(order by g_start desc) from gift; --5등

select rank(600001) within group(order by g_start desc) from gift
where g_start is not null; -- DB마다 다르지만 오라클은 null이 우선순위1순위라 null 빼줘야함, mysql은 우선순위 반대임
```



![image](https://user-images.githubusercontent.com/65274952/128650510-84b78696-3363-4d33-8059-904a53dd81ea.png)

### ex student table



```sql
select * from student;
```



![image](https://user-images.githubusercontent.com/65274952/128650575-2e91a110-1872-4e24-a76e-3a844bd30624.png)

```sql

select * from student;

--키가 168인사람 몇번째로 큰지
select rank(168)  within group  ( order by height desc)from student
where height is not null;
--몸무개가 58인 사람은 몇번째인지 등수 구하기
select rank (168)  within group  ( order by weight desc)from student
where weight is not null;
--g_end가 200000 , 600000 값 출력 (any 이용)
select * from gift where g_end= any(200000 , 600000);
--학생들의 키의 합과 평균 가장키가큰 친구 작은 친구 출력
select sum(height), avg(height), max(height), min(height) from student
where height is not null;
```



### 집합함수와 일반필드(GRUOP BY)

![image](https://user-images.githubusercontent.com/65274952/128652064-07b31032-21be-46e9-bc1c-0cca50f382d0.png)



같이 사용할 수 없다.

사용하려면?

집합함수로 설정해줘야한다.



```sql
select grade, sum(height), sum(weight),avg(height),sum(weight) From student
group by grade; -- 부분합 (소계)

```

**Group By 가 있을 때는 Where 절을 사용할 수 없다!!**

**Having 을 사용해야한다**



```sql
--emp type 별로 급여합 평균 최고급여 최하급여 구하기
desc emp2;
select emp_type, sum(pay),avg(pay),max(pay),min(pay) 
from emp2
group by emp_type;
```



### gruop by having

-- 조건 : where, having ( group by 일때 만 가능)



```sql
select grade, sum(height), sum(weight), avg(height), avg(weight)
from student
Group by grade
having avg(height) >173; --gruop by 에서 조건을 부여하기 위해서는 having 사용

```



### PK 와 FK

FK를 쓰면 좋은점

예를들면 FK가 학과라면

학과 테이블의 학과명에서  값을 가져오면 존재하지 않는 값이 들어갈 일이 없다.

![image](https://user-images.githubusercontent.com/65274952/128652915-0ed9b056-22a2-4249-a504-0767d2dea89a.png)

나중에는 학과코드 자리에 학과명을 넣을 수 도 있다 (join 통해)



### ex group by 

```sql
--문제1 emp2 테이블에서 deptno(부서)별 급여합, 평균 구하기
select deptno, sum(pay), round(avg(pay),0) 
from emp2 
group by deptno;

--문제2  emp2 테이블에서 emp_type 별 급여합, 평균 구하기
select  emp_type, sum(pay), round(avg(pay),0) 
from emp2 
group by emp_type;

--문제3  emp2 테이블에서  직급별 급여합, 평균 구하기
select  position, sum(pay), round(avg(pay),0) 
from emp2 
group by position;

--문제4  emp2 테이블에서  과장 직급의 급여합, 평균 구하기
select  position, sum(pay), round(avg(pay),0) 
from emp2 
group by position
having position = '과장';

```





# 숫자함수

숫자는 기본적으로 실수형으로 인식한다.



![image](https://user-images.githubusercontent.com/65274952/128654474-c01a16c4-663e-4dd3-8dff-7114f874bb47.png)

### round

```sql
select round(12.3456789,2), 
round(12.3456789,0), 
round(12.7456789,2), 
round(12.3426789, 2) 
from dual;
--라운드는 값과 그 값을 소수점 몇자리 까지 표시할지 나온다.

```



![image](https://user-images.githubusercontent.com/65274952/128654759-cd55ba3b-7987-4303-ac86-30c9fd708375.png)



### ceil

```sql

--ceil 은 무조건 소수점이 있으면 더 큰 정수형으로 반환함
--음수의 경우도 마찬가지 음수도 더 큰 수로 반환시킴

```

![image](https://user-images.githubusercontent.com/65274952/128654805-576896f2-9b86-4afe-b7a8-6f9fbccc6a31.png)

![image](https://user-images.githubusercontent.com/65274952/128654829-d9972dd8-6bf4-444e-abfa-231de0f0349e.png)

음수의 경우도 마찬가지 음수도 더 큰 수로 반환시킴



### floor

```sql
select floor(12.34), floor(-12.34) from dual;

--floor 은 무조건 소수점이 있으면 더 작은 정수형으로 반환함
--음수의 경우도 마찬가지 음수도 더 작은 수로 반환시킴

```

![image](https://user-images.githubusercontent.com/65274952/128654955-eba63a24-5a7f-494c-80b5-ca7acd35e711.png)

![image](https://user-images.githubusercontent.com/65274952/128654959-ad1f4ff1-0b7d-494a-9233-d4da2d760dbf.png)

음수의 경우도 마찬가지 음수도 더 큰 수로 반환시킴



![image](https://user-images.githubusercontent.com/65274952/128654985-4451fac3-fdd7-4d67-9281-2892bb538ae4.png)



### mod

나머지 값을 구한다.

```sql
select mod(7,3) from dual;
```



![image](https://user-images.githubusercontent.com/65274952/128655025-2371d8a2-c6db-4bf3-a1d6-917b3135c0a2.png)





### trunc

소수점 표시하겠다고 정한 값 이후의 자릿수는 연산에 반영하지 않고 날린다.



반올림 버림 올림 없이 보이는뒷자리는 그냥 다 날린다.



```sql
select trunc(12.3456789,2), 
trunc(12.3456789,0), 
trunc(12.7456789,2), 
trunc(12.3426789, 2) 
from dual;
```

![image](https://user-images.githubusercontent.com/65274952/128655150-f00d13e8-8c90-43f3-8348-6342929606ae.png)



# 문자열 함수

![image](https://user-images.githubusercontent.com/65274952/128655211-862d78d7-af10-48ca-bc36-81d218489edb.png)

### instr

매칭되는 문자열을 찾아서 그 값의 인덱스를 반환한다

 **sql은 인덱스가 0이아닌 1부터 시작한다.**

``` sql
select instr('abcd', 'b') from dual;
--2
select instr('abcdasldkfjlsakbdf', 'b', -1) from dual;
-- -1을 넣으면 뒤에서 부터 찾아서 인덱스를 반환해준다.
```



### rpad lpad

```sql
select lpad('abcd', 20, '#')from dual;

select rpad('abcd', 20, '@')from dual;
```

![image](https://user-images.githubusercontent.com/65274952/128656870-2e333cd4-b7e9-4628-9817-65ab0f5480cd.png)

![image](https://user-images.githubusercontent.com/65274952/128656887-9a61d582-f803-4557-8988-e8f233f3718d.png)

ex

```sql
select RPAD(dname, 10 ,'*') "rpad연습" from dept2;
-- 뒤의 수는 byte 인데
한글은 한글자에 2byte
사장실 보면 3글자 + 공백4개인데
6byte라 그렇다.
숫자는 1byte
영어도 1btte


select RPAD(dname, 10 ,'1234567890') "rpad연습" from dept2;
select LPAD(dname, 10 ,'1234567890') "lpad연습" from dept2;

```

![image](https://user-images.githubusercontent.com/65274952/128656930-bbb5f777-08de-4b64-92e0-628f02b961a1.png)





### length, lengthb

```sql
select length('hello') from dual; --5
select lengthb('hello') from dual; --5

select length('12345') from dual; -- 5
select lengthb('hello') from dual; --5

select length('한글') from dual; --2
select lengthb('한글') from dual; --6 한글 한글자당 3byte 처리

```

한글은 3byte 처리

```sql
select dname, length(dname), lengthb(dname) from dept2;
```



![image](https://user-images.githubusercontent.com/65274952/128657216-b41b5553-9ee0-4830-bf48-8a99900dfa4e.png)







### substring, substringb

```sql
select substr('1234567890', 3) from dual; --3번째 인덱스 뒤로 끝까지 출력
select substr('1234567890', 3,2) from dual; -- 3 번째 인덱스 포함해서 2개 출력

select dname, substr(dname, 3) from dept2;
select dname, substr(dname, 3,2) from dept2;

select dname, substrb(dname, 3) from dept2;
select dname, substrb(dname, 3,2) from dept2;
```



### ex 문자열 예제

### 

```sql
select tel, instr(tel,')')
from student
where deptno1 =101;
```

![image](https://user-images.githubusercontent.com/65274952/128658498-77ca30f8-9396-4892-a5b7-4b111fdaac02.png)

```sql

select tel, substr(tel, 1, instr(tel,')') -1) 
"지역번호"
from student
where deptno1 =101;

```

![image](https://user-images.githubusercontent.com/65274952/128658468-eff15a85-80be-4c81-af52-4a5d01236a13.png)

### 정규식

```sql
select name, rtrim(regexp_replace(name, '(.)','\=1'),'-') "변경후"
from student
where deptno1 =103;

select name, rtrim(regexp_replace(birthday, '(/)','\\'),'-') "변경후"
from student
where deptno1 =103;
```

자주 쓰냐 하면 그렇지는 않지만

알아두면 유용하게 쓸 때가 있다.



# 날짜함수

![image](https://user-images.githubusercontent.com/65274952/128657946-90ff66f9-a290-4a1d-8c55-2d9021975ce4.png)

### sysdate

```sql
select sysdate from dual;
```

![image](https://user-images.githubusercontent.com/65274952/128657925-97c96a39-5bd6-4b5d-a469-c9d42ef80543.png)



# 형변환 함수

![image](https://user-images.githubusercontent.com/65274952/128658003-9113c457-87c0-435d-a73e-faaf65666c18.png)



### to_char(datetime, format)

```sql
select to_char(sysdate, 'YYYY-MM-DD HH:MI:SS') from dual;

select to_char(sysdate, 'YY-MM-DD HH:MI')
from dual;

select to_char(sysdate, 'YY-MM-DD SS') 
from dual;

select to_char(sysdate, 'yy-mm-dd-hh24:mi-ss') from dual;

```

Oracle 에서는 대소문자 구별 안하지만 자바에서는 무조건 소문자로 형식을 표시해줘야함.

![image](https://user-images.githubusercontent.com/65274952/128658177-40512361-d500-4dd9-aede-02422632f305.png)



### Java 에서 Date Format

 *대소문자 구분하여 작성해야함

**yyyy : 년도**

**MM : 월**

**dd : 일**

**hh : 시간**

**mm : 분**

**ss : 초**

**SSS 밀리초**

```java
package test.date;

import java.text.SimpleDateFormat;
import java.util.Date;

public class cap_or_not {

    public static void main(String[] args) {

        try{
            //Date to String 변환
            SimpleDateFormat sDate = new SimpleDateFormat("yyyy-MM-dd");
            SimpleDateFormat sDate1 = new SimpleDateFormat("yyyy.MM.dd");
            SimpleDateFormat sDate2 = new SimpleDateFormat("yyyy-MM-dd hh:mm:ss.SSS");

            System.out.println(sDate.format(new Date()));
            System.out.println(sDate1.format(new Date()));
            System.out.println(sDate2.format(new Date()));

            //String to Date 변환
            String from = "2019.03.03";
            SimpleDateFormat fDate = new SimpleDateFormat("yyyy.MM.dd"); //같은 형식으로 맞춰줌
            Date n = fDate.parse(from);

            System.out.println(n.getTime());

        }catch (Exception e){
            System.out.println(e.toString());
        }

    }
}
```

**출력결과 :** 

![image](https://user-images.githubusercontent.com/65274952/128658902-61e482c8-281a-43ee-ad6b-b2a263b453e1.png)

### to_char(number, format)

### to_data(문자열)

### to_number(문자열)



# 자투리

> 함수를 여러개 섞어서 사용 할 수 있음
>
> ```sql
> select deptno as "학     과", round(avg(nvl (bonus,0))) 
> from professor
> group by deptno;
> ```
>
> 

![image](https://user-images.githubusercontent.com/65274952/128653140-045e0de5-0339-4657-9b8d-271c89bbcad1.png)

