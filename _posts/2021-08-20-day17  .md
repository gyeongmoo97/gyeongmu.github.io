---
title: Day17 Object
layout: single
author_profile: true
read_time: true
comments: true
share: true
related: true
categories:
- DB
description: .

meta_keywords: java,static,memory
last_modified_at: '2021-08-10 12:00:00 +0800'
toc: true
toc_sticky: false
toc_label: 목차
---



#  JavaScript Objects

자바스크립트 - 클래스를 만들 수 있다.

클래스 = 객체에 대한 설계도



자바스크립트 안에서 클래스 없이 코드에서 객체를 표현 할 수 있다.



java 의 필드와 메서드에 해당하는 

properties, methods 가 있다.

![image](https://user-images.githubusercontent.com/65274952/130159459-e36b8a62-8471-4645-bc4e-59b4f4ebb87a.png)



## Object Definition

```javascript
const car = {type:"Fiat", model:"500", color:"white"};
```

중괄호에서  (  ,  ) 로구분되는 하나하나가 값(property)이나 함수(method)가 올 수 있다.

이름: 내용    //형태로 선언됨.



```javascript
const person = {
  firstName: "John",
  lastName : "Doe",
  id       : 5566,
  fullName : function() {
    return this.firstName + " " + this.lastName;
  }
};

```



## Accessing Object Properties

~~~javascript
cont car = {name:"그랜저", price: 5000};

var name = car.name;
var name = car["name"];


~~~

변수에 접근하는 방식은 2가지가 있는데

위의 방식이 더 편하다.

그렇다면 아래의 방식은 어떤 의미가 있을까?

```javascript
var key = "그랜저";
var name = car["key"] -> name 조회
```

**변수를 활용**해서 **객체의 property 접근**할때 아래의 방법 사용함



## 예제

# 추가정리하기



객체 내부에서 객체의 값을 지칭하려면 this를 반드시 써야한다.

```html
<!DOCTYPE html>

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>

  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/css/bootstrap.min.css">
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.slim.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/js/bootstrap.bundle.min.js"></script>

</head>

<body>
  <script>
    const car = {
      name: "그랜저",
      price: 5000,
      speed: 0,
      start: function(){
        console.log("시동을 겁니다.")
      },
      //this 는 객체 자신을 말함
      //반드시 무조건 property, method 호출시 this를 붙혀야한다.
      setSpeed: function(value){
        if(this.speed == 0){
          this.start();
        }
        
        this.speed=value;
      },


      getSpeed: function(){
        return this.speed;
      }

      // setSpeed: function(value){
      //   speed=vlaue;
      // } 자바에서는 this 생략하고 이렇게 작성가능
    };

  


    //group 사용하면 출력내용 덩어리를 확인하기가 쉬움
    //속성값 읽기
    console.group("car 객체 내용");
    console.log(car.name, car["name"]);
    console.log(car.price, car["price"]);
    console.groupEnd();

      //속성 값 변경
      car.name="소나타";
      car.price=3000;

      //
      // car = {} -> 상수로 선언해서 객체를 바꾸면 안됨


      //메서드 호출
      car.start();
      car.setSpeed(100);
      console.log("변경속도", car.speed);
      let curSpeed = car.getSpeed();
      console.log("cursped", curSpeed);


  </script>
</body>

</html>
```



자바와는 다르게

**객체가 선언된 뒤  property, method 를 추가할 수 있다**

```javascript
  const car = {};
    // const car = new object();
    // 동일한 표현임 근데 new object는 복잡해서 잘 안씀
    //js 는 동적으로 멤버 변수를 추가 할 수 있다.
    car.name = "그랜저";
    car.price = 5000;
    car.start = function(){
      console.log("시동을 겁니다");
    }    
    

     //속성값 읽기
     console.group("car 객체 내용");
    console.log(car.name, car["name"]);
    console.log(car.price, car["price"]);
    console.groupEnd();
    car.start();
    
```



객체 값은 주소를 가진다. const 라고 하면 **주소가 불변하다**는 의미

**데이터가 변경 불가능한게 아님** 

주소가 안바뀌는거임 데이터는 변경가능

```javascript
const person = {
  firstName:"John",
  lastName:"Doe",
  age:50, eyeColor:"blue"
}

const x = person;
x.age = 10;      // Will change both x.age and person.age
```

### 메모리공간

stack, heap 공간이 있을 때

객체는 heap에 생성된다. 참조변수는 stack에 선언된다.

![image](https://user-images.githubusercontent.com/65274952/130161844-090e463d-22d2-40e7-b01e-770a982086eb.png)

person.firstName 값에 접근하는 과정은

person 이라는 객체의 주소를 가지고 있는 stack 공간의

변수에 접근하여

heap 주소로 이동한뒤 firstName 값을 얻는다.

```javascript
const x = person
```

은 x 에 참조변수 값(주소)을 넣어주면 person과 같은 주소값을 가지게 됨.

 person 처럼 사용가능함.



교제를 보면서 참조변수를 조금 더 이해해보면 좋겠다.



# JSON.stringify() 

![image](https://user-images.githubusercontent.com/65274952/130163601-afc17792-c3fe-4e45-9883-f90a36f034c0.png)



```javascript
console.log(car);
    let strJson = JSON.stringify(car);
    console.log("strcar", strJson);
    
```

![image](https://user-images.githubusercontent.com/65274952/130163712-65e14542-23c5-49f3-bb57-9af61dc6668b.png)

객체를 문자열로 문자열을 객체로 만들 수 있다.

객체를 문자열로 만들어 주는 방법으로



JSON

자바스크립트 오브젝트 표현법이라는 의미임





json 문법상

문자열로 표현해 줄때는 ""따옴표로 감싸서 넣어줘야한다



객체를 json 으로 json을 문자열로

```
 console.log(car);
    let strJson = JSON.stringify(car);
    console.log("strcar", strJson);
    let car2 = JSON.parse(strJson);
    console.log(car2);
    //pasre 해석해서 복원한다는 의미

```

![image](https://user-images.githubusercontent.com/65274952/130164114-ba3e57a2-1bdb-4592-8c74-e1673d93175b.png)

**하지만 메서드는 json에 담을 수 없다.** 그래서 사라짐



# JavaScript Accessors

```
// Create an object:
const person = {
  firstName: "John",
  lastName: "Doe",
  language: "en",
  get lang() {
    return this.language;
  }
};
```



예제

```
<!DOCTYPE html>

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>

  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/css/bootstrap.min.css">
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.slim.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/js/bootstrap.bundle.min.js"></script>

</head>

<body>
  <script>
     const car = {
      name: "그랜저",
      price: 5000,
      speed: 0,
      start: function(){
        console.log("시동을 겁니다.")
      },
      //this 는 객체 자신을 말함
      //반드시 무조건 property, method 호출시 this를 붙혀야한다.
      setSpeed: function(value){
        if(this.speed == 0){
          this.start();
        }
        
        this.speed=value;
      },
      // get currSpeed() {
      //   return this.speed;
      // }
      //get 2개는 못씀
      get meterSpeed() {
        let result = this.speed *1609.34
        return result;
      }

      // getSpeed: function(){
      //   return this.speed;
      // }
    };
    console.log(car.speed);
    console.log(car.meterSpeed);

    // get speed : 
    // getSpeed 

  </script>
</body>

</html>
```

getter를 만든느 문법

```
// getSpeed: function(){
      //   return this.speed;
      // }
```

이런걸 만들어도 되긴함.

get을 통해서 변수의 값 또는 가공된 변수의 값을 제공할 수 있다.

잘 사용하지는 않음



```
const person = {
  firstName: "John",
  lastName: "Doe",
  language: "",
  set lang(lang) {
    this.language = lang;
  }
};

// Set an object property using a setter:
person.lang = "en";

// Display data from the object:
document.getElementById("demo").innerHTML = person.language;
```

대입연산자 왼쪽에 와서 

새로운값을 받아들인다.

```
 setSpeed: function(value){
        if(this.speed == 0){
          this.start();
        }
        this.speed=value;
      },
      set meterSpeed(meter){
        var result = meter/1609;
        this.speed = result;
      },
      
    
```

setter 따로 만들 수 있지만

set 으로 만들 수 있음



마찬가지로 잘 사용하지 않음

# JavaScript Object Constructors

자바와 마찬가지로 클래스를 만들고 클래스를 바탕으로 객체를 찍어낼 수 있다.

이전 문법 거의 함수나 다름이 없어 보인다.

```
function Person(first, last, age, eye) {
  this.firstName = first;
  this.lastName = last;
  this.age = age;
  this.eyeColor = eye;
}
```



```
const myFather = new Person("John", "Doe", 50, "blue");
const myMother = new Person("Sally", "Rally", 48, "green");
```



실습

```
 	//function 인데
    //안에 this 가 있다 -> 생성자

    function Car(name, price){
      this.name = name;
      this.price = price;
      this.start = function(){
        console.log("시동을 겁니다.");
      };
    }

    //생성자로부터 객체 생성
    const myCar = new Car("포르쉐", 200000000);
    const yourCar = new Car("람보르기니", 500000000);

    //객체 사용
    console.log(myCar);
    console.log(myCar.name, myCar.price);
    myCar.start();

    console.log(yourCar);
    console.log(yourCar.name, yourCar.price);
    yourCar.start();
```

**function** 인데 안에 **this** 가 있다 -> **생성자**



생성자를 정의하면 외부에서 불러와서 넣어서 사용, 

한번 선언으로 객체 여러개 만들기 가능 -> 코드 재사용성 상승



## Built-in JavaScript Constructors

js가 미리 정의해둔 생성자

```
new String()    // A new String object
new Number()    // A new Number object
new Boolean()   // A new Boolean object
new Object()    // A new Object object
new Array()     // A new Array object
new RegExp()    // A new RegExp object
new Function()  // A new Function object
new Date()      // A new Date object
```



# JavaScript Object Prototypes

자바의 object 객체가 가장 최상위 객체이듯

자바스크립트도 상위 객체로 프로토타입이 있다



```javascript
function Person(first, last, age, eye) {
  this.firstName = first;
  this.lastName = last;
  this.age = age;
  this.eyeColor = eye;
}

Person.prototype.name = function() {
  return this.firstName + " " + this.lastName
};

const myFather = new Person("John", "Doe", 50, "blue");
document.getElementById("demo").innerHTML =
"My father is " + myFather.name(); 
```

Person 의 상위객체의 name 에 function 을 선언해줘서 

Person 에서 name을 쓸 수 있게 됨.

잘안씀

![image](https://user-images.githubusercontent.com/65274952/130166706-1c449620-a6d8-4007-bba2-b976f6b5e99e.png)

이전 문법을 활용해서 무언가 상속받아 만드는 것 아니면 

굳이 이해하기 힘든 프로토타입으 사용할 이유는 없음

예전에 이런게 있었다 정도 알면됨.



![image](https://user-images.githubusercontent.com/65274952/130167144-fe0638c9-b9fd-40d3-b579-fcf18b4b7aa5.png)

reference는 안쓴다. 속성 값을 바꾸는 것을 너무 번거롭게 할 뿐임

교수님도 한번도 사용하는 것을 못보았다고 한다.

##  map()

```
// Create Objects
const apples = {name: 'Apples'};
const bananas = {name: 'Bananas'};
const oranges = {name: 'Oranges'};

// Create a new Map
const fruits = new Map();

// Add new Elements to the Map
fruits.set(apples, 500);
fruits.set(bananas, 300);
fruits.set(oranges, 200);
```

map을 만들 수 있다. -> key value 로 값을 관리가능하다. 

정도 알면됨.



# js의 자료구조

![image](https://user-images.githubusercontent.com/65274952/130167716-a1650dfe-2813-4f8f-80ff-31bcfa8f0b59.png)

하지만 교수님 피셜 set map 잘 안씀





# Classes

리엑트에서 Class 아주 많이씀

view에 서는 그렇게 잘 안씀





# 자투리

> ​	 const car = {};
> ​    // const car = new object();
> ​    // 동일한 표현임 근데 new object는 복잡해서 잘 안씀



> //js 는 동적으로 멤버 변수를 추가 할 수 있다.
>
>java는 객체를 만들고 나서는 멤버 변수 추가 불가

> 객체 자체 출력
>
> console.log(car);
>
> ![image](https://user-images.githubusercontent.com/65274952/130163368-b186df33-cab5-4c6c-bb68-afe41f2741b8.png)



> 앵귤러js, 리엑트 , 앵귤러, view 가 순서대로 프레임워크가 나옴
>
> 앵귤러js 아주 많은 기능을 가짐 -> 복잡
>
> 리엑트는 경량화 진행하였음 -> 더 쉬워졌지만 기능이 조금 모자라짐
>
> 리엑트는 간단한 문제도 js 를 작성해서 기능을 직접 구현해야하는 부분이 더 많음
>
> view 는 둘의 장점을 적절히 혼합하여 만듦



> 교수님 피셜 view가 리엑트 보다는 낫다. 요즘 업체들도 많이 view를 사용한다. 
