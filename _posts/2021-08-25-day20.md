---
title: Day20 AJAX
layout: single
author_profile: true
read_time: true
comments: true
share: true
related: true
categories:
- DB
description: .

meta_keywords: java,static,memory
last_modified_at: '2021-08-10 12:00:00 +0800'
toc: true
toc_sticky: false
toc_label: 목차
---



# AJAX

AJAX = **A**synchronous **J**avaScript **A**nd **X**ML.

Asynchronous = 비동기

XMLHttpRequest 라는 브라우저가 제공하는 객체를 사용해도 괜찮은데

보통은 이걸 사용하지 않음 jquery 로 ajax 사용함



## 동기와 비동기

코드를 위에서 아래 방향으로 해석하다가 중간에 다른 프로세스와 통신, 외부 코드를 실행 요청하여 외부 코드 실행이 진행된 후 그 결과를 받아 수행하는 방식

<img src="https://user-images.githubusercontent.com/65274952/130706467-fa32840e-23f0-455e-9559-b7f0924e8798.png" alt="image" style="zoom:50%;" />



지금 실행되는 코드에서 외부에 무언가를 요청하는것과 별개로 기존 코드 해석을 위에서 아래로 진행하고 외부요청에 대한 결과를 처리해 주는 코드는 따로 실행된다.

<img src="https://user-images.githubusercontent.com/65274952/130706616-72dd5d99-e837-460c-b79c-360eebe05d73.png" alt="image" style="zoom:50%;" />



![image](https://user-images.githubusercontent.com/65274952/130706688-1d00a975-9c74-43e0-9d8e-2b78f268dcf7.png)



https://www.w3schools.com/js/js_ajax_intro.asp

비동기가 이루어지는 방식

- 1. An event occurs in a web page (the page is loaded, a button is clicked)
- 2. An XMLHttpRequest object is created by JavaScript
- 3. The XMLHttpRequest object sends a request to a web server
- 4. The server processes the request
- 5. The server sends a response back to the web page
- 6. The response is read by JavaScript
- 7. Proper action (like page update) is performed by JavaScript





## $.ajax()

![image](https://user-images.githubusercontent.com/65274952/130706956-bb6d7c42-13a0-4b76-8deb-363ae503d4a4.png)

- **url**

  Type: [String](http://api.jquery.com/Types/#String)

  A string containing the URL to which the request is sent.

  요청이 전송될 url

- **settings**

  Type: [PlainObject](http://api.jquery.com/Types/#PlainObject) => 중괄호로 작성해야한다는 뜻

  A set of key/value pairs that configure the Ajax request. All settings are optional. A default can be set for any option with [$.ajaxSetup()](https://api.jquery.com/jQuery.ajaxSetup/). See [jQuery.ajax( settings )](https://api.jquery.com/jQuery.ajax/#jQuery-ajax-settings) below for a complete list of all settings.

  URL이 settings 안에 들어가도 되고 맨앞에 넣어도 된다.

  URL이 앞에 없으면 settings 에 들어가 있는거다.

- The `$.ajax()` function returns the `XMLHttpRequest`



비동기 방식이기때문에 응답받은 후 별도의 처리가 필요한데 그건 어떻게 처리하나?



```javascript
var jqxhr = $.ajax( "example.php" )
  .done(function() {
    alert( "success" );
  })
  .fail(function() {
    alert( "error" );
  })
  .always(function() {
    alert( "complete" );
  });
 
// Perform other work here ...
 
// Set another completion function for the request above
jqxhr.always(function() {
  alert( "second complete" );
});
```

```javascript
  .done(function() {
    alert( "success" ); =>성공하면done의 콜백실행
  })
  .fail(function() {
    alert( "error" ); =>실패하면fail의 콜백실행
  })
  .always(function() {
    alert( "complete" ); =>언제든 콜백실행
  });
각각이 다 콜백함수다.

```



![image](https://user-images.githubusercontent.com/65274952/130707523-733a36b5-1c4f-4dc2-96ee-3f78367f6ef4.png)

위에서 아래로 파일을 해석

php 파일을 요청했을 때 -> 성공또는 실패시 콜백함수가 있고 성공실패 여부와 관계없이 실행되는 콜백함수가 있다.

이런식으로 비동기 처리가 이루어 짐



```javascript
function requestAjax(){
      console.log("1");
      $.ajax("exam01_server.html") //외부로 요청 전송.
        .done(()=>{
          console.log("done call back");
        })
        .fail(()=>{
          console.log("fail call back");
        })
        .always(()=>{
          console.log("always call back");
        }); //마지막에는 ; 붙혀야한다
        console.log("2");
    }

```

![image](https://user-images.githubusercontent.com/65274952/130707940-cbb020d7-80d8-4609-9533-ddad9bddc31a.png)





 $.ajax("exam01_server.html")  를 작성한 뒤에 산출물은

success의  Data로 들어온다.

**success**

Type: [Function](http://api.jquery.com/Types/#Function)( [Anything](http://api.jquery.com/Types/#Anything) data, [String](http://api.jquery.com/Types/#String) textStatus, [jqXHR](http://api.jquery.com/Types/#jqXHR) jqXHR )



**error**

Type: [Function](http://api.jquery.com/Types/#Function)( [jqXHR](http://api.jquery.com/Types/#jqXHR) jqXHR, [String](http://api.jquery.com/Types/#String) textStatus, [String](http://api.jquery.com/Types/#String) errorThrown )

![image](https://user-images.githubusercontent.com/65274952/130709840-70ede963-8cde-4351-9e9a-984ec1682c59.png)



ajax를 읽지못하는 오류가 생겨서

```html
  <script src="https://code.jquery.com/jquery-3.4.1.js"></script>
```

코드를 넣어줬다





예제3

![image](https://user-images.githubusercontent.com/65274952/130713831-170f177e-87ca-4289-b050-99a254b79283.png)



예제4

settings 개체의 다양한 속성을 이용하여 성공시 실패시의 내 call back 함수 지정가능 이전에 많이 사용한 방식

요즘은 promise 와 비슷한 방식으로 사용가능한 예제 1,2,3 방식(url).done.fail.always을 사용?



## .load()

```javascript
$( "#result" ).load( "ajax/test.html" );

```

버튼클릭이 아니라

비동기 처리가 다 끝나면 자동으로 특정 값에 내용을 넣어준다.

![image](https://user-images.githubusercontent.com/65274952/130716853-879186dd-0dbb-4481-80f4-82fb957c12f2.png)

```javascript
  $(function(){
      $("#content").log("exam06_server.html");
    });
```





# JS Promises (중요)

당장 일어난 이벤트에 대한 처리가 아니라

앞으로 미래에 일어날 일에 대해 어떻게 할건지에 대해 정의할 수 있음.



```javascript
//Promise 객체 생성(정의), 생성당시 callback 함수 생성
    //resolve - 해결 reject 거절
    const promise = new Promise((resolve, reject) =>{
      //시간을 요하는 작업 코딩
      console.log("시간을 요하는 작업 진행...");
      const success = true;
      if(success){
        resolve(); //success callback
      } else{
        reject(); //fail callback
      }
    });


    //Promise 실행
    //resolve 실행되면then 이 실행된다.
    // reject 실행되면 catch 실행된다.
    //finally 는 성공과 상관없이 실행됨
    //각각은 안에 callback 메서드가 들어간다.
    promise 
      .then(() =>{
        console.log("작업 성공");
      })
      .catch(() =>{
        console.log("작업 실패");
      })
      .finally(() =>{
        console.log("작업 마무리");
      });
```

보통은 이미 promise의 정의를 제공하는 API를 사용하게 되기 때문에

then catch  부분을 더 자주 작성하게 될 것이고 

promise 정의는 할 기회가 거의 없을 수 있다.

![image](https://user-images.githubusercontent.com/65274952/130719057-59d9290f-33d1-4d87-b802-d7513558f174.png)



```javascript
const promise = new Promise((resolve, reject) =>{
      //시간을 요하는 작업 코딩
      console.log("시간을 요하는 작업 진행...");
      const success = false;
      if(success){
        resolve({message:"성공 메시지"}); //success callback
      } else{
        reject({message:"에러 메시지"}); //fail callback
      }
    });


    //Promise 실행
    //성공적으로 resolve 하면 then 이 실행된다.
    //fail 해서 reject 하면 catch 실행된다.
    //finally 는 성공과 상관없이 실행됨
    //각각은 안에 callback 메서드가 들어간다.
    promise 
      .then((response) =>{
        console.log("작업 성공" +response.message);
      })
      .catch((response) =>{
        console.log("작업 실패",response.message);
      })
      .finally(() =>{
        console.log("작업 마무리");
      });
```

response로 promise 에서 값을 받을 수 있다.

response.message 로 메시지를 받을 수 있다.



# JS Async/Await





```javascript
function  fun1() {
      const promise = new Promise((resolve, reject) => {
        //시간을 요하는 작업 작성
        const success = true;
        if(success) resolve("작업 결과");
        else    reject("에러 내용");

      });
      return promise;
    }
```

이런식으로 promise return 하는 api 많다. 이러한 promise 를 받으면 어떻게 처리할거냐?





![image](https://user-images.githubusercontent.com/65274952/130721787-ae914e2e-feae-4917-a3e0-884c90e7506f.png)

![image](https://user-images.githubusercontent.com/65274952/130721797-33205797-356a-4fde-9ce8-b7df1b55dfae.png)

![image](https://user-images.githubusercontent.com/65274952/130721808-b2d3d582-60de-4697-9b6c-7d7e0d9b5d4a.png)







![image](https://user-images.githubusercontent.com/65274952/130721968-234765d1-c861-40ac-abdc-28cf32287ab9.png)

비동기로 동작

비동기 안에서는 동기작업으로 실행

doWork2() 자체는 비동기





![image](https://user-images.githubusercontent.com/65274952/130722147-83cf0709-b227-47a6-8bff-7f88d6c054b1.png)

버튼이 눌려서 이 코드블럭이 실행되면 동기 처리라서 3초 걸리는 코드 가 돌아가는동안 다른거 먹통



![image](https://user-images.githubusercontent.com/65274952/130722166-4a970623-e4b9-4ee9-b446-9d17166c855b.png)

누르자 마자 다른거 할 수 있음 하지만 결과를 보려면 3초가 걸리는건 맞음

doWork2 는 비동기 라서 다른거 하면서 동시에 병렬적으로 처리 되는데

await는 promise 가 다 될때 까지 기다려줌



await 있으면 async 써야하고

async 쓰면 try catch 써야함



---

![image](https://user-images.githubusercontent.com/65274952/130730429-e3693985-b244-4882-b05e-a6dc341533b4.png)

복잡한 코드 -> async 사용하면 같은 기능으로 가독성 좋아짐







async 함수는 비동기적으로 처리된다.

```javascript
   async function doWork() {
      try{
        const response1 = await work1();
        console.log("작업성공1", response1);
        const response2 = await work2();
        console.log("작업성공2", response2);


      } catch(response){
        console.log("작업실패", response);
      } finally{
        console.log("마무리");
    }
      
    }

    function handleBtn2() {
      console.log(1);
      doWork();
      console.log(2);
    }
```

![image](https://user-images.githubusercontent.com/65274952/130731022-ab553319-6da1-42a8-8c1a-c42dcef512cf.png)

async 함수는 비동기적으로 처리된다.





![image-20210825124210932](C:\Users\mwe22\AppData\Roaming\Typora\typora-user-images\image-20210825124210932.png)







# 자투리

![image](https://user-images.githubusercontent.com/65274952/130706887-0f720d92-d686-4266-805a-87d658952648.png)

. 붙은건 JQuery 객체에 사용

JQuery 붙은건 JQuery 그대로 사용 혹은 $ 붙혀서 사용



> json  에서
>
> [] -> 배열
>
> {} -> 객체
