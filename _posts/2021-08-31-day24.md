

---
title: Day23 코드분석(작성중)
layout: single
author_profile: true
read_time: true
comments: true
share: true
related: true
categories:

- DB
description: .

meta_keywords: java,static,memory
last_modified_at: '2021-08-10 12:00:00 +0800'
toc: true
toc_sticky: false
toc_label: 목차
---

 {% raw %}

# web xml

배치기술자

spring의 요소를 어디에 어떻게 배치하는지를 기술한다.



web.xml은 스프링의 주요한 규칙,설정을 담고있는 파일인 servlet, root context-context.xml의 위치도 담고있다.

![image](https://user-images.githubusercontent.com/65274952/131421148-878f523d-9ea8-436c-b152-38b79b07e7a5.png)

![image](https://user-images.githubusercontent.com/65274952/131421170-f2d30f96-789e-4955-a394-3ece86d8c323.png)



resource 에 배치하는것 보다 src/main/resources에 위치하는게 전자정부프로젝트에서 일반적이다.

옮기기위해 변경함 classpath: 는 classes가 저장되는경로인 

```xml
<context-param>
    <param-name>contextConfigLocation</param-name>
    <!-- 	<param-value>/WEB-INF/spring/root-context.xml</param-value> -->
    <param-value>classpath:spring/root/*.xml</param-value>
</context-param>

<!-- Creates the Spring Container shared by all Servlets and Filters -->
<listener>
    <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>
</listener>

<!-- Processes application requests -->
<servlet>
    <servlet-name>appServlet</servlet-name>
    <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
    <init-param>
        <param-name>contextConfigLocation</param-name>
        <!-- 			<param-value>/WEB-INF/spring/appServlet/*.xml</param-value> -->
        <param-value>classpath:spring/appServlet/*.xml</param-value>
    </init-param>
    <load-on-startup>1</load-on-startup>
</servlet>

```

![image](https://user-images.githubusercontent.com/65274952/131422283-fd01f096-0b34-477b-8094-124d37d2ec95.png)

모두 classapath에 있으면 관리하기가 편리하다








![image](https://user-images.githubusercontent.com/65274952/131422482-ddf7be6b-38ab-45e6-ac1c-34540f9d446d.png)

최종산출물에서 classes 에 꼭 java 만들어가는게 아니다 클래스를 실행하기위해 필요한 것이 다 들어간다.

message 도 들어간다.

```
ch04_error_en.properties
ch04_error_ko.properties
```

브라우저가 사용하는 언어에 맞게 스프링이 알아서 파일을 선택한다.

구분자는

**ch04_error**_ko.properties

**ch04_error** 

까지 이다.

## 접미사가 없는 message



![image](https://user-images.githubusercontent.com/65274952/131422681-1f11c0bb-03b5-44e9-a2a0-c8591eeb95fb.png)

위의 상황에서 한국도 영어도 아닌 언어가 오면 언어에 대한 접미사가 없는파일을 사용한다.



## message 와 Spring연결

root context xml로 연결





xml의 구조 (root context xml)

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd">
	
	<!-- Root Context: defines shared resources visible to all other web components -->
		
</beans>

```

xml 시작부분은 인코딩 방식과 버전을 나타낸다.



아래 최초로나타내는 것은 root 태그이다. 

bean, property는후에 자세히 다룬다.



```xml
	   <!-- 에러 및 국제화 메시지를 위한 ResourceBundleMessageSource 관리빈 등록  -->
   <bean id="messageSource"
      class="org.springframework.context.support.ResourceBundleMessageSource">   
      <property name="basenames">
         <list>
            <value>message.ch04_error</value>
         </list>
      </property>
      <property name="defaultEncoding" value="UTF-8"/>
   </bean>   
```



```xml
  <value>message.ch04_error</value>
```

기본경로가 classpath 이기 때문에 messager를 web-inf에 넣으면안된다.

message 아래의 ch04_error 중 언어에 맞는것을 뽑아준다.



```xml
  <bean id="messageSource" class="org.springframework.context.support.ResourceBundleMessageSource">   
```

이 class를 통해서 메시지를 스프링에 전달? 후에 더 자세히 다룬다.





# @Valid(폼 유효성 검사 요구)를 사용하기 위한 의존성 설정(pom.xml)

mvn repository

https://mvnrepository.com/artifact/javax.validation/validation-api/2.0.1.Final

![image](https://user-images.githubusercontent.com/65274952/131423486-9d0b928c-0951-4ba3-ac93-0517ed15a599.png)

2.01final

```xml
<dependency>
    <groupId>javax.validation</groupId>
    <artifactId>validation-api</artifactId>
    <version>2.0.1.Final</version>
</dependency>
```



![image](https://user-images.githubusercontent.com/65274952/131423655-d6ea3467-9d6b-478e-81ac-a9b2bc698959.png)

종속성 추가하면 로컬저장소인 .m2 폴더에 라이브러리가 추가된다.



# validator 클래스 작성



## 폼단위

한개의 폼에서만 사용함. 폼당 하나씩 만듦, 로그인 페이지 1개, 회원가입 페이지 1개, 배송지 입력 페이지 1개 이런식 

## 필드단위

아이디 비밀번호 이메일 등등 많이 들어가면 각각 만들어야한다.

그런데 중복으로 사용하면 필드단위가 이득이다.

예를들어 아이디를 로그인을 위해 사용하고, 비밀번호 찾기에 사용하고, 회원가입에 사용하고 등등 로그인을 사용하는 빈도가 높으면 필드단위 validator 클래스를 사용하면  중복코드가 줄어든다.



# 유효성 검사 클래스작성

![image](https://user-images.githubusercontent.com/65274952/131425396-6bdeae0c-38c0-4054-9e98-d3df831affb8.png)
![image](https://user-images.githubusercontent.com/65274952/131425581-5bde03ea-43c0-4537-9d79-6b38611374f2.png)





```java
//모든 데이터를 유효성검사할 수 없기 때문에 범위를 지정해야한다. 
// 어떤 대상을 유효성검사할 수 있고 없고를 판단해서 유효성검사 가능한 대상이면 true 아니면 false됨
//supports 의 arg로 dto가 들어간다.

public boolean supports(Class<?> clazz) {
    logger.info("실행");
    //여기에(clazz) 들어가는 클래스가 Ch04Member에 대입될 수 있는지
    boolean check = Ch04Member.class.isAssignableFrom(clazz);

    return false;
}
```

여기에(clazz) 들어가는 클래스가 Ch04Member에 대입될 수 있는지를 확인하여 true false 를 반환한다.



**대입될 수 있다**는 것의 의미는 **상속**의 의미에서 clazzz 객체는 Ch04Member.class가 됩니까? 라는것 요약하면

**Ch04Member** 이거나 **Ch04Member의 자식** 클래스만 **clazz 위치에** 올 수 있다.



![image](https://user-images.githubusercontent.com/65274952/131426026-fbf072f9-ecd9-46fd-864f-680039167631.png)
자동타입변환 - 좁은범위의 타입은 넓은 범위에 포함될 수 있다.

자식객체는 부모 타입에 assgin 될 수 있다.

 

![image](https://user-images.githubusercontent.com/65274952/131426142-b5ee6c0c-b755-4693-9de2-86b4e3b648cf.png)

B는 A 입니까? 라고 물어보는 것과 같다. (is 관계)

B is A? 



```java
//supports 가 true 가 되면 validate 함수가 자동으로 실행된다.
//false면 아무일도 일어나지 않는다.
@Override
	public void validate(Object target, Errors errors) {
		
	}


```



검사할 대상과 error 내용을 arg로 받는다.

```java
@Override
	public void validate(Object target, Errors errors) {
		logger.info("실행");
		Ch04Member member = (Ch04Member) target;
	}
```



### 강제 타입 casting

```java
Ch04Member member = (Ch04Member) target;
위에서 대입가능한 객체만 받았으니까 강제 타입변환 시켜줌
```

### message와 연결

```java
//mid 검사
//내용이 없는 경우
if(member.getMid() ==null || member.getMid().trim().equals("")) {
errors.rejectValue("mid","errors.mid.required");
}

---------------------------------------
errors.rejectValue("mid","errors.mid.required");
```

**mid** 에서 문제가 생겼고, message의  **errors.mid.required** 키값에 해당하는 문제임을 errors 객체에 넘겨줌



이때 **mid** 는 그냥 쓰는게 아닌 **dto 에 있는 변수명**과 **같아야한다**.



```java
errors.rejectValue("mid","errors.mid.minlength", new Object[] {4}, "");
```

errors.mid.minlength=회원 아이디는 {0}자 이상 입력해야 합니다.

==> 동적으로 입력하는 부분이 있다.

new Object[] {4} 넣으면 동적인 부분에 4가 들어감

""은 키값에 해당하는 문자열이 없으면 대체해서 넣어줄 문자열이다.



```java
//mtel 검사
if(member.getMtel() ==null || member.getMtel().trim().equals("")) {
    errors.rejectValue("mtel","errors.mtel.required");
} else {
    String regex = "^\\d{3}-\\d{3,4}-\\d{4}$";
    Pattern pattern = Pattern.compile(regex);
    Matcher matcher = pattern.matcher(member.getMtel());
    if(!matcher.matches()) {
        errors.rejectValue("mtel","errors.memail.invalid");
    }
}
```





## valid 실행의 시점

```java
@PostMapping("/method2")
public String method2(@Valid Ch04Member member) {
    logger.info("mid :" + member.getMid());
    logger.info("mpassword : " + member.getMpassword());
    logger.info("memail : " + member.getMemail());
    logger.info("mtel : " + member.getMtel());
    return "redirect:/ch04/content";
}

---------------------------------------------
    public String method2(@Valid Ch04Member member) {
    
    @Valid 는 javax.validation 사용함
    Validation 할때 사용할 Validator는 어디에서 매칭시켜줄까? 
```

컨트롤러는 요청 처리의 역할이다. 즉 올바른 데이터가 들어간 것을 상정하고 작동한다.

유효성검사는 method2에 dto 객체를 넣기 전에 이루어져서 컨트롤러의 처리과정에는 유효한 값만 들어가야한다. 


![image](https://user-images.githubusercontent.com/65274952/131429723-28bd9ee3-d595-4aac-8dc9-9001f9fff3ad.png)



###  Validation 할때 사용할 Validator는 어디에서 매칭시켜줄까? 





# 자투리



> 정규식을 넣을 때 이클립스 자체에서 문자열에 \ 가 있으면\\\\\ 로변환하는 과정이 있어 내 코드가 뒤틀릴 수 있음 아래의 코드는 교수님 코드 

![image](https://user-images.githubusercontent.com/65274952/131429087-cec08054-c073-4a6d-a5a5-490cfffa1f79.png)

 {% endraw %}