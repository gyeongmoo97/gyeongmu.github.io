

---
title: Day24 Valid (작성중)
layout: single
author_profile: true
read_time: true
comments: true
share: true
related: true
categories:

- DB
description: .

meta_keywords: java,static,memory
last_modified_at: '2021-08-10 12:00:00 +0800'
toc: true
toc_sticky: false
toc_label: 목차
---

 {% raw %}

# web xml

배치기술자

spring의 요소를 어디에 어떻게 배치하는지를 기술한다.



web.xml은 스프링의 주요한 규칙,설정을 담고있는 파일인 servlet, root context-context.xml의 위치도 담고있다.

![image](https://user-images.githubusercontent.com/65274952/131421148-878f523d-9ea8-436c-b152-38b79b07e7a5.png)

![image](https://user-images.githubusercontent.com/65274952/131421170-f2d30f96-789e-4955-a394-3ece86d8c323.png)



resource 에 배치하는것 보다 src/main/resources에 위치하는게 전자정부프로젝트에서 일반적이다.

옮기기위해 변경함 classpath: 는 classes가 저장되는경로인 

```xml
<context-param>
    <param-name>contextConfigLocation</param-name>
    <!-- 	<param-value>/WEB-INF/spring/root-context.xml</param-value> -->
    <param-value>classpath:spring/root/*.xml</param-value>
</context-param>

<!-- Creates the Spring Container shared by all Servlets and Filters -->
<listener>
    <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>
</listener>

<!-- Processes application requests -->
<servlet>
    <servlet-name>appServlet</servlet-name>
    <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
    <init-param>
        <param-name>contextConfigLocation</param-name>
        <!-- 			<param-value>/WEB-INF/spring/appServlet/*.xml</param-value> -->
        <param-value>classpath:spring/appServlet/*.xml</param-value>
    </init-param>
    <load-on-startup>1</load-on-startup>
</servlet>

```

![image](https://user-images.githubusercontent.com/65274952/131422283-fd01f096-0b34-477b-8094-124d37d2ec95.png)

모두 classapath에 있으면 관리하기가 편리하다








![image](https://user-images.githubusercontent.com/65274952/131422482-ddf7be6b-38ab-45e6-ac1c-34540f9d446d.png)

최종산출물에서 classes 에 꼭 java 만들어가는게 아니다 클래스를 실행하기위해 필요한 것이 다 들어간다.

message 도 들어간다.

```
ch04_error_en.properties
ch04_error_ko.properties
```

브라우저가 사용하는 언어에 맞게 스프링이 알아서 파일을 선택한다.

구분자는

**ch04_error**_ko.properties

**ch04_error** 

까지 이다.

## 접미사가 없는 message



![image](https://user-images.githubusercontent.com/65274952/131422681-1f11c0bb-03b5-44e9-a2a0-c8591eeb95fb.png)

위의 상황에서 한국도 영어도 아닌 언어가 오면 언어에 대한 접미사가 없는파일을 사용한다.



## message 와 Spring연결

root context xml로 연결





xml의 구조 (root context xml)

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd">
	
	<!-- Root Context: defines shared resources visible to all other web components -->
		
</beans>

```

xml 시작부분은 인코딩 방식과 버전을 나타낸다.



아래 최초로나타내는 것은 root 태그이다. 

bean, property는후에 자세히 다룬다.

root context xml

```xml
	   <!-- 에러 및 국제화 메시지를 위한 ResourceBundleMessageSource 관리빈 등록  -->
   <bean id="messageSource"
      class="org.springframework.context.support.ResourceBundleMessageSource">   
      <property name="basenames">
         <list>
            <value>message.ch04_error</value>
         </list>
      </property>
      <property name="defaultEncoding" value="UTF-8"/>
   </bean>   
```



```xml
  <value>message.ch04_error</value>
```

기본경로가 classpath 이기 때문에 messager를 web-inf에 넣으면안된다.

message 아래의 ch04_error 중 언어에 맞는것을 뽑아준다.



```xml
  <bean id="messageSource" class="org.springframework.context.support.ResourceBundleMessageSource">   
```

이 class를 통해서 메시지를 스프링에 전달? 후에 더 자세히 다룬다.





# @Valid(폼 유효성 검사 요구)를 사용하기 위한 의존성 설정(pom.xml)

mvn repository

https://mvnrepository.com/artifact/javax.validation/validation-api/2.0.1.Final

![image](https://user-images.githubusercontent.com/65274952/131423486-9d0b928c-0951-4ba3-ac93-0517ed15a599.png)

2.01final

```xml
<dependency>
    <groupId>javax.validation</groupId>
    <artifactId>validation-api</artifactId>
    <version>2.0.1.Final</version>
</dependency>
```



![image](https://user-images.githubusercontent.com/65274952/131423655-d6ea3467-9d6b-478e-81ac-a9b2bc698959.png)

종속성 추가하면 로컬저장소인 .m2 폴더에 라이브러리가 추가된다.



# validator 클래스 작성



## 폼단위

한개의 폼에서만 사용함. 폼당 하나씩 만듦, 로그인 페이지 1개, 회원가입 페이지 1개, 배송지 입력 페이지 1개 이런식 

## 필드단위

아이디 비밀번호 이메일 등등 많이 들어가면 각각 만들어야한다.

그런데 중복으로 사용하면 필드단위가 이득이다.

예를들어 아이디를 로그인을 위해 사용하고, 비밀번호 찾기에 사용하고, 회원가입에 사용하고 등등 로그인을 사용하는 빈도가 높으면 필드단위 validator 클래스를 사용하면  중복코드가 줄어든다.



# 유효성 검사 클래스작성

![image](https://user-images.githubusercontent.com/65274952/131425396-6bdeae0c-38c0-4054-9e98-d3df831affb8.png)
![image](https://user-images.githubusercontent.com/65274952/131425581-5bde03ea-43c0-4537-9d79-6b38611374f2.png)





```java
//모든 데이터를 유효성검사할 수 없기 때문에 범위를 지정해야한다. 
// 어떤 대상을 유효성검사할 수 있고 없고를 판단해서 유효성검사 가능한 대상이면 true 아니면 false됨
//supports 의 arg로 dto가 들어간다.

public boolean supports(Class<?> clazz) {
    logger.info("실행");
    //여기에(clazz) 들어가는 클래스가 Ch04Member에 대입될 수 있는지
    boolean check = Ch04Member.class.isAssignableFrom(clazz);

    return false;
}
```

여기에(clazz) 들어가는 클래스가 Ch04Member에 대입될 수 있는지를 확인하여 true false 를 반환한다.



**대입될 수 있다**는 것의 의미는 **상속**의 의미에서 clazzz 객체는 Ch04Member.class가 됩니까? 라는것 요약하면

**Ch04Member** 이거나 **Ch04Member의 자식** 클래스만 **clazz 위치에** 올 수 있다.



![image](https://user-images.githubusercontent.com/65274952/131426026-fbf072f9-ecd9-46fd-864f-680039167631.png)
자동타입변환 - 좁은범위의 타입은 넓은 범위에 포함될 수 있다.

자식객체는 부모 타입에 assgin 될 수 있다.

 

![image](https://user-images.githubusercontent.com/65274952/131426142-b5ee6c0c-b755-4693-9de2-86b4e3b648cf.png)

B는 A 입니까? 라고 물어보는 것과 같다. (is 관계)

B is A? 



```java
//supports 가 true 가 되면 validate 함수가 자동으로 실행된다.
//false면 아무일도 일어나지 않는다.
@Override
	public void validate(Object target, Errors errors) {
		
	}


```



검사할 대상과 error 내용을 arg로 받는다.

```java
@Override
	public void validate(Object target, Errors errors) {
		logger.info("실행");
		Ch04Member member = (Ch04Member) target;
	}
```



### 강제 타입 casting

```java
Ch04Member member = (Ch04Member) target;
위에서 대입가능한 객체만 받았으니까 강제 타입변환 시켜줌
```

### message와 연결

```java
//mid 검사
//내용이 없는 경우
if(member.getMid() ==null || member.getMid().trim().equals("")) {
errors.rejectValue("mid","errors.mid.required");
}

---------------------------------------
errors.rejectValue("mid","errors.mid.required");
```

**mid** 에서 문제가 생겼고, message의  **errors.mid.required** 키값에 해당하는 문제임을 errors 객체에 넘겨줌



이때 **mid** 는 그냥 쓰는게 아닌 **dto 에 있는 변수명**과 **같아야한다**.



```java
errors.rejectValue("mid","errors.mid.minlength", new Object[] {4}, "");
```

errors.mid.minlength=회원 아이디는 {0}자 이상 입력해야 합니다.

==> 동적으로 입력하는 부분이 있다.

new Object[] {4} 넣으면 동적인 부분에 4가 들어감

""은 키값에 해당하는 문자열이 없으면 대체해서 넣어줄 문자열이다.



```java
//mtel 검사
if(member.getMtel() ==null || member.getMtel().trim().equals("")) {
    errors.rejectValue("mtel","errors.mtel.required");
} else {
    String regex = "^\\d{3}-\\d{3,4}-\\d{4}$";
    Pattern pattern = Pattern.compile(regex);
    Matcher matcher = pattern.matcher(member.getMtel());
    if(!matcher.matches()) {
        errors.rejectValue("mtel","errors.memail.invalid");
    }
}
```





## valid 실행의 시점

```java
@PostMapping("/method2")
public String method2(@Valid Ch04Member member) {
    logger.info("mid :" + member.getMid());
    logger.info("mpassword : " + member.getMpassword());
    logger.info("memail : " + member.getMemail());
    logger.info("mtel : " + member.getMtel());
    return "redirect:/ch04/content";
}

---------------------------------------------
    public String method2(@Valid Ch04Member member) {
    
    @Valid 는 javax.validation 사용함
    Validation 할때 사용할 Validator는 어디에서 매칭시켜줄까? 
```

컨트롤러는 요청 처리의 역할이다. 즉 올바른 데이터가 들어간 것을 상정하고 작동한다.

유효성검사는 method2에 dto 객체를 넣기 전에 이루어져서 컨트롤러의 처리과정에는 유효한 값만 들어가야한다. 


![image](https://user-images.githubusercontent.com/65274952/131429723-28bd9ee3-d595-4aac-8dc9-9001f9fff3ad.png)



###  Validation 할때 사용할 Validator는 어디에서 매칭시켜줄까? 

```java

	@InitBinder("ch04Member")
	public void ch04Member(WebDataBinder binder) {
		logger.info("실행");
		binder.setValidator(new Ch04MemberJoinFormValidator());
	}
	
	@PostMapping("/method2")
	public String method2(@Valid Ch04Member member) {
	...
	}
```



### 스프링의 IOC사용법

dto에 값이 들어오면 스프링이 객체를 관리하기 시작함

그 객체를 호출하려면 그 객체의 첫글자를 소문자로한 이름을 id 처럼 활용가능하다.

@InitBinder("ch04Member") 첫자를 소문자로 요청한 경우 



1. /ch04/method2 요청
2. Ch04Member member 생성
3. 첫글자를 소문자로 만든 값이 id 처럼 사용가능함(관리이름)ch04Member
4. bind -연결시킴



그런데 아래와 같이 2개 이상의 메서드가 아래 처럼 같은 dto를 받아온다면?

-> 하나의 binder로는 2개의 다른 폼에대해 따로따로 처리못함

```java
	
	@InitBinder("ch04Member")
	public void ch04Member(WebDataBinder binder) {
		logger.info("실행");
		binder.setValidator(new Ch04MemberJoinFormValidator());
	}
	
	@PostMapping("/method2")
	public String join(@Valid Ch04Member member) {
		logger.info("mid :" + member.getMid());
		logger.info("mpassword : " + member.getMpassword());
		logger.info("memail : " + member.getMemail());
		logger.info("mtel : " + member.getMtel());
		return "redirect:/ch04/content";
	}

	@PostMapping("/method3")
	public String login(@Valid Ch04Member member) {
		logger.info("mid :" + member.getMid());
		logger.info("mpassword : " + member.getMpassword());
		return "redirect:/ch04/content";
	}
	
```

위의 경우는 join login 모두다 같은 유효성검사가 실행된다. 

이유는 같은 Ch04Member dto를 사용했기 때문에 같은 **관리 이름**( IOC에서 객체에 접근하기 위한 ID역할 )이 같게된다 (defualt는 객체에서 앞글자를 소문자로 바꾼 내용)

그래서 따로 이름을 바꿔줘야 맞게 돌아간다.







IOC에서 관리하는 객체에 접근하는 id 의default 는 객체의 첫글자를 소문자로 만든 것이다.

하지만 명시적으로 작성하여 객체에 접근하는 id를 변경할 수 있다.

```java
@ModelAttribute("loginForm")
```





```java
//	@InitBinder("ch04Member")
@InitBinder("joinForm")
public void ch04Member(WebDataBinder binder) {
    logger.info("실행");
    binder.setValidator(new Ch04MemberJoinFormValidator());
}

@PostMapping("/method2")
public String join(@ModelAttribute("joinForm") @Valid Ch04Member member) {
    logger.info("mid :" + member.getMid());
    logger.info("mpassword : " + member.getMpassword());
    logger.info("memail : " + member.getMemail());
    logger.info("mtel : " + member.getMtel());
    return "redirect:/ch04/content";
}
```



![image](https://user-images.githubusercontent.com/65274952/131432676-d1a273e0-0c75-4bef-8837-85b213cf843c.png)



### 표현식

```
<%@ taglib prefix="form" uri="http://www.springframework.org/tags/form"%>
```

이제 form 태그 사용가능

![image](https://user-images.githubusercontent.com/65274952/131433358-5044b185-d403-4748-a02f-64efc69b6675.png)



```
<form:errors cssClass="text-danger" path="joinForm.mid" />
```

에러를 여기에 출력하겠다는 내용



## valid 흐름

1. message 언어별 , default  파일 생성
2. validator 클래스를 만들어줌

![image](https://user-images.githubusercontent.com/65274952/131434028-f47d1171-7b0d-48b7-809a-cf1d03dac3b3.png)

![image](https://user-images.githubusercontent.com/65274952/131434011-f7e48275-17ae-4528-bc8f-72a2f3e19be7.png)

![image](https://user-images.githubusercontent.com/65274952/131434047-f656c8e5-743f-4a8e-b8aa-4454ad682b84.png)
서포트는 검사할 수 있는객체인지 아닌지 파악함
![image](https://user-images.githubusercontent.com/65274952/131434089-49a27db3-ae80-445d-a89c-efbd874c0bd7.png)
컨트롤러의 클래스를 검사함
같은 클래스이기 때문에 true 리턴함
![image](https://user-images.githubusercontent.com/65274952/131434119-503fed72-aec3-46f0-892d-deeb1465b07a.png)
surport 이후 valid 가 자동실행됨
valid 실행 후에 join 실행

![image](https://user-images.githubusercontent.com/65274952/131434209-3f4f6126-f8cd-43fa-acc4-3bd3c92deb9a.png)
마지막으로 컨트롤러의 메서드 실행



추가로 에러 메시지가 출력 가능한 이유는 

![image](https://user-images.githubusercontent.com/65274952/131434330-8ffca8d9-5db2-4c49-9944-c294fe2adbc4.png)

path 가 중요함

joiniform.mid 에서 관리되는 객체에서 문제가 생기면 err를 출력하겠다는 의미임

![image](https://user-images.githubusercontent.com/65274952/131434389-3eac4897-b9ba-42ce-8652-133d07463e3b.png)

properties 파일의 error 의 key 값 



## 브라우저 언어설정 변경하여 en test



![image](https://user-images.githubusercontent.com/65274952/131434597-e33bbf02-9773-4092-ae93-316b0e799d62.png)
![image](https://user-images.githubusercontent.com/65274952/131434637-13ba7046-f53d-463e-928d-fd2b04fe0b1b.png)

![image](https://user-images.githubusercontent.com/65274952/131434606-87a47992-2275-4b06-9c4a-493ac95f7dad.png)

error 메시지 여러가지 만드는 이유는 브라우저가 지원하는 언어에 따라 다른 문구를 제공하는 국제화를 위한 과정



# 필드단위 valid

1. 클래스생성 + implement Validator (org.spring) + interface method 구현



![image](https://user-images.githubusercontent.com/65274952/131435873-25069693-52d8-4aa8-9ecd-a4349b2d6948.png)
자바의... 은 가변길이 변수이다.



# 중간요약

dto와 dto를 통해서 값을 넘겨받는 부분은 이미 있다고 가정함



1. root context xml에서 메시지를 Spring과 연결

```xml
	   <!-- 에러 및 국제화 메시지를 위한 ResourceBundleMessageSource 관리빈 등록  -->
   <bean id="messageSource"
      class="org.springframework.context.support.ResourceBundleMessageSource">   
      <property name="basenames">
         <list>
            <value>message.ch04_error</value>
         </list>
      </property>
      <property name="defaultEncoding" value="UTF-8"/>
   </bean>   
```

2.  implements Validator : Validator를 구현한 validator용도의 클래스 선언 후 인터페이스 메서드 구현

   ```java
   public class Ch04MemberLoginFormValidator implements Validator {
   
       @Override
       public boolean supports(Class<?> clazz) {
           return false;
       }
       @Override
       public void validate(Object target, Errors errors{
       }
   }
   ```

**supports** 는 **isAssignableFrom** 메서드로 해당 객체가 사용가능한지 체크하고

supports가 true를 반환하면 자동으로 **validate**가 실행됨 

**Errors errors** 객체에는 error 내용이 저장됨





**validate** 메서드에서는 Errors 객채에 오류 내용을 저장한다.

```java
if(member.getMid() ==null || member.getMid().trim().equals("")) {
    errors.rejectValue("mid","errors.mid.required");
}
```

error를 저장하는 방법은 **rejectValue**메서드를 활용하는것이다.

"mid","errors.mid.required"

**arg**로 **dto**의 **변수명**, **messsage**의 **key**값을 필요로 한다.

dto 해당 **변수**에서 해당 **key**의 유효성검증 **실패**내역을 **errors에 저장**해준다.



3. 위의 과정에서 만든 Validator 클래스를 Controller 와 연결한다.

controller 와 연결하는 과정에서는 Spring의 IOC 특성을 활용해야한다.



IOC를 위해 dto에 값이 들어오면 스프링이 객체를 관리하기 시작한다.



그 객체를 호출하려면 그 객체의 첫글자를 소문자로 바꾼 이름을 id 처럼 활용할 수 있다. ex) Ch04Member -> 값이들어온 순간 **스프링이 값을 관리**하고 **호출명을 사용하여 호출**가능, defualt 호출자는 ch04Member

-> 한 dto를 다른 메서드가 참조하여 다른 방식의 valid 가 필요한 경우에는 defualt 호출명을 사용해서는 안됨

```java
@ModelAttribute("joinForm") 
```

와 같은 어노테이션 활용하여 호출명을 변경해줌



4. 호출명을 InitBinder 어노테이션을 활용하여 객체의 값과 valiator 클래스를 연결해줌

```java
@InitBinder("joinForm")
	public void joinFormSetValidator(WebDataBinder binder) {
		logger.info("실행");
		binder.addValidators(
			new Ch04MemberIdValidator(),
			new Ch04MemberPasswordValidator(),
			new Ch04MemberEmailValidator(),
			new Ch04MemberTelValidator()
		);
	}
```



5.  validator 가 반환한 error를 사용하여 웹페이지 반환 

   Errors, BindingResult 객체를 활용하여 error 에 따른 페이지 반환 처리하여 유효성에 따라 에러메시지와 입력폼을 다시 반환 하거나, 처리후 페이지를 반환하면됨

![image](https://user-images.githubusercontent.com/65274952/131443201-92c5697e-35b4-457d-b60b-a230338ede1a.png)

```java
// BindingResult 사용예제
@PostMapping("/method2")
public String join(@ModelAttribute("joinForm") @Valid Ch04Member member, BindingResult bindingReult) {
    logger.info("실행");
    if (bindingReult.hasErrors()) {
        logger.info("다시 입력폼 제공 + err msg");
        return "ch04/content";
    } else {
        logger.info("정상 요청 처리후 응답 제공");
        return "redirect:/ch04/content";
    }

}
```

6. content.jsp 반영

```jsp
<%@ taglib prefix="form" uri="http://www.springframework.org/tags/form"%>
```

지시자를 통해서 form 태그를 사용하는 값은 uri의 내용에 영향을 받게됨.



7. form 태그로 값 전달

```jsp
<form:errors cssClass="text-danger" path="joinForm.mid" />
<form:errors cssClass="text-danger" path="joinForm.mpassword" />
<form:errors cssClass="text-danger" path="joinForm.memail" />
<form:errors cssClass="text-danger" path="joinForm.mtel" />
```

path 부분이 핵심적이다.

 joinform.mid 에서 관리되는 객체에서 문제가 생기면 err를 출력하겠다는 의미임

![image](https://user-images.githubusercontent.com/65274952/131434389-3eac4897-b9ba-42ce-8652-133d07463e3b.png)

properties 파일의 error 의 key 에 맞는 값을 반환한다.







1. 
2. 





# 자투리



> 정규식을 넣을 때 이클립스 자체에서 문자열에 \ 가 있으면\\\\\ 로변환하는 과정이 있어 내 코드가 뒤틀릴 수 있음 아래의 코드는 교수님 코드 

![image](https://user-images.githubusercontent.com/65274952/131429087-cec08054-c073-4a6d-a5a5-490cfffa1f79.png)



>![image](https://user-images.githubusercontent.com/65274952/131435873-25069693-52d8-4aa8-9ecd-a4349b2d6948.png)
>자바의... 은 가변길이 변수이다.













 {% endraw %}