

---
title: Day28
layout: single
author_profile: true
read_time: true
comments: true
share: true
related: true
categories:

- DB
description: .

meta_keywords: java,static,memory
last_modified_at: '2021-08-10 12:00:00 +0800'
toc: true
toc_sticky: false
toc_label: 목차
---

 {% raw %}



# ResponseBody

브라우저와 웹어플리케이션(스프링 프레임워크)가 있다고 했을 때 

요청과 응답을 주고 받는 방식은 HTTP 통신이다



요청과 응답의 HTTP 구조는 같다. 

시작행이 들어가고 헤더가 들어간 뒤 빈 행 다음에 본문(바디)가 들어간다



```java
response.setContentType()
printWriter Pw = ;
pw.println("");
```

PW는 문자열을 횡단위로 출력하기위한 보조수단이다.

출력스트림을 보낸다는것은 어딘가 출력을 하겠다는건데 어디에다가 하겠다는 것인가?

response body에 출력한다.

``` java
response.setContentType()
```

setConetentType은 응답 헤더의 값을 부여해줌



```java
printWriter Pw = ;
pw.println("");
```

문자열을 응답 바디에 넣는다.



```java
그림파일을 보낼 때에도 이런식으로 바디에 넣어준다.
OutputStream os = ...;
os.write(...);
```



# @ResponseBody

return 값을 리스폰스 바디로 연결시켜준다. 

제이슨, 바이트 배열, 문자열 등이 전달된다.



 ![image](https://user-images.githubusercontent.com/65274952/132145518-a2c919c8-c29c-4d23-bf1a-43531526dba6.png)



# 예외처리

기본적으로는 예외내용을 HTML로 만들어서 보여주는 것이다.



# 예외 예시

```java
@RequestMapping("/content")
public String content(String data) {
    logger.info("실행");
    if(data.equals("java")) {
	// data 가 null 이라면 nullPointerException 발생
    }
    return "ch10/content";
}
```

![image](https://user-images.githubusercontent.com/65274952/132145917-c5c4eabc-9747-44db-938e-139a19d0bb3d.png)

## 에러의 종류

500 번대 에러는 서버단의 문제 클라이언트는 잘못 없음

400 번대는 클라이언트의 잘못된 url 요청, 권한이 없는 클라이언트의 요청이 발생한 경우 - 서버는 잘 못 없음



# 에러가 발생한 페이지를 그대로 보여준다면?

상당히 웹페이지의 신뢰성이 떨어진다. 사용자에게 친절하게 에러에 대한 내용을 설명할 수 있는 페이지를 만들어야한다.



예외가 발생하지 않게 하는것이 가장 최고겠지만 예외가 발생한 경우 어떤 방식으로 처리하여서 사용자에게 알려줄 것 인지 배워본다.



500err jsp

```jsp
<%@ page contentType="text/html; charset=UTF-8"%>

<%@ include file="/WEB-INF/views/common/header.jsp"%>

<!--카드 시작  -->
<div class="card m-2">

	<div class="card-header">
	 서버 실행 오류
	</div>

	<!--카드 내용 시작  -->
	<div class="card-body">
		<p>어떠한 이유 때문에 서버에서 처리하지 못하였습니다.</p>
		<p>잘못된 데이터가 넘어왔다거나 일시적 서버 오류 이므로 잠시후 다시 시도해 주세요.</p>
		<div>
		<!--  어떤 경로에서 예외가 발생하는 지 모르기 때문에 절대경로 사용해야함-->
			<%-- "${pageContext.request.contextPath}" -> 우리의 root context 는 /인데 빈값 취급임 그래서 / 붙인다--%>
			<a href="${pageContext.request.contextPath}/" class ="btn btn-success btn-sm">홈으로 가기</a>
		</div>
	</div>
	<!--카드 내용 끝 -->
</div>
<!--카드 끝 -->

<%@ include file="/WEB-INF/views/common/footer.jsp"%>
```









# 자투리



> 자바 교제의 장 제목 아래의 절 제목에 대해 누군가가 질문하였을 때 이야기를 할 수 있는지 없는지 확인해봐야 한다. 아는데 설명할 수 없다면 다시 공부를 해보는게 좋다.



# 예외처리 방법 1

```java
@RequestMapping("/content")
public String content(String data) {
    logger.info("실행");
    try {
        if(data.equals("java")) {
            //NullPointerException
        }
    }catch (Exception e){
        return "error/500";
    }
    return "ch10/content";
}
```

모든 예외에 대해 이런 방식으로 try catch 사용하면

1. 작성이 번거롭고
2. 수정도 번거롭다 ( 예외를 처리하는 파일의 이름이 바뀐다거나 하면 곤란함)





## 스프링은  예외처리 전담 클래스를 생성하여 예외를 관리한다.

예외처리 전담 클래스는 예외별로 어떠한 처리를 할지에 대한 정보를 가지고 있다.



try catch 같은 예외처리를 컨트롤러에서 작성 할 필요없이 예외가 발생하면 자동으로 예외처리 전담 클래스가 예외를 받아서 처리하게 된다.



# @ Component

//스프링에게 was가 시작될 때 IoC 컨테이너에 미리 해당 클래스의 객체를 만들어 
//두어서 사용할 수 있게 만들어 달라는 의미의 어노테이션
@Component 



# @ControllerAdvice

//모든 컨트롤러와 관련이 있게 된다. 모든 컨트롤러에게 관여 가능한 클래스가 된다.
//모든 컨트롤러에게 영향을 미치는 클래스를 만들기 위해 설정
@ControllerAdvice



# 컨트롤러를 통한 예외처리 실행과정

![image](https://user-images.githubusercontent.com/65274952/132147976-719dddb3-2724-4610-b512-9e87098814c7.png)
예외가 발생하면
발생지점 아래로 더이상 진행되지 않고
![image](https://user-images.githubusercontent.com/65274952/132147993-7d77459e-db68-457a-bbbd-627c46912f30.png)
예외처리 내용이 실행된다.

## @Component 어노테이션에 의해 객체가 생성되는 시점 확인

```http
정보: Initializing Spring DispatcherServlet 'appServlet'
INFO : com.mycompany.webapp.exception.Ch10ExceptionHandler.<init>() - 실행
9월 06, 2021 10:25:15 오전 org.apache.jasper.servlet.TldScanner scanJars
```



# try catch , @ControllerAdvice

try catch를 사용하면 예외처리 컨트롤러를 거치지 않는다. 예외가 바로 처리 되기 때문에 예외처리 클래스로 연결되지 않는다.



# Exception, RuntimeException

예외의 최상위 클래스는 Exception 이다.

![image](https://user-images.githubusercontent.com/65274952/132148994-c6764daf-edd6-4096-b157-99a16f3546e6.png)

RuntimeException 류의 예외가 발생할 수 있는 메서드는 반드시 try catch를 작성해줘야한다.

예외의 상속관계를 알기위해서는 DOC를 참고하면 좋다.

https://docs.oracle.com/javase/7/docs/api/



대표적으로는 IO 와 관련한 메서드를 사용하려면 반드시 예외처리를 해주어야 한다.



# 언급되지 않은 예외 처리

```java

	// 스프링은 구체적인 예외상황을 다 찾을 후에 포괄적인 예외 상황을 처리한다.
//	runtimeException 으로 나머지 상황을 다 처리 가능하다.
	// Exception에 RuntimeException이 포함된다.
	@ExceptionHandler
//	public String handleClassCastException(RuntimeException e) {
	public String handleClassCastException(Exception e) {
		logger.info("실행");
		return "error/500_cast";
	}
```



 {% endraw %}